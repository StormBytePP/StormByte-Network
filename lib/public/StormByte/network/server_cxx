#include <StormByte/network/server.hxx>
#include <StormByte/util/system.hxx>

#ifdef LINUX
#include <sys/select.h>
#include <unistd.h>
#include <cstring> // For strerror
#else
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#endif

#include <iostream>
#include <format>

using namespace StormByte::Network;

Server::Server(std::shared_ptr<Logger::Log> logger, std::shared_ptr<const Connection::Handler> handler):
m_logger(logger), m_socket(nullptr), m_status(Connection::Status::Disconnected), m_handler(handler) {}

Server::~Server() noexcept {
	Disconnect();
}

StormByte::Expected<void, ConnectionError> Server::Connect(const std::string& hostname, const unsigned short& port, const Connection::Protocol& protocol) noexcept {
	if (Connection::IsConnected(m_status.load()))
		return StormByte::Unexpected<ConnectionError>("Server is already connected");

	m_socket = std::make_unique<Socket::Server>(protocol, m_handler);
	auto expected_listen = m_socket->Listen(hostname, port);
	if (!expected_listen)
		return StormByte::Unexpected(expected_listen.error());
	
	// Start a thread to accept client connections
	m_status.store(Connection::Status::Connected);
    m_acceptThread = std::thread(&Server::AcceptClients, this);
	m_clientCheckThread = std::thread(&Server::CheckClients, this);

	return {};
}

void Server::Disconnect() noexcept {
	if (m_status.load() == Connection::Status::Disconnected)
		return;

	m_status.store(Connection::Status::Disconnecting);

	// We wait for the check clients to finish
	// As it will take care of stopping accepting new clients
	if (m_clientCheckThread.joinable()) {
		m_clientCheckThread.join();
	}

	// When reaching here, all clients should be disconnected and deleted from vector

	m_socket.reset();

	m_status.store(Connection::Status::Disconnected);
}

void Server::AcceptClients() {
	std::cout << "Start accepting clients" << std::endl;
	while (m_status.load() == Connection::Status::Connected) {
		fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(m_socket->Handle(), &readfds); // Add the socket's file descriptor
        struct timeval timeout;
        timeout.tv_sec = 2; // Timeout for 5 seconds
        timeout.tv_usec = 0;

        int activity = select(m_socket->Handle() + 1, &readfds, NULL, NULL, &timeout);
        if (activity > 0 && FD_ISSET(m_socket->Handle(), &readfds)) {
            // The socket is ready for accepting
            auto expected_client_socket = m_socket->Accept();
            if (expected_client_socket) {
                expected_client_socket.value().Status() = Connection::Status::Negotiating;
				AddClient(std::move(expected_client_socket.value()));
				std::cout << "Client accepted" << std::endl;
            }
        }
	}
	std::cout << "End accepting clients" << std::endl;
}

Socket::Client& Server::AddClient(Socket::Client&& client) {
	// Lock vector access
	std::lock_guard<std::mutex> lock(m_clientsMutex);

	// Add the client to the vector
	m_clients.push_back(std::make_unique<Socket::Client>(std::move(client)));

	// Start a thread to handle the client's messages
	Socket::Client& client_socket = *m_clients.back();
	auto client_handle = *client_socket.Handle();
	m_clientMsgThreads.insert(std::make_pair(
		client_handle,
		std::thread(
			[this, &client_socket] {
				std::cout << "Client message thread started" << std::endl;
				HandleClientMessages(client_socket);
				std::cout << "Client message thread ended" << std::endl;
			}
		)
	));
	m_clientThreads.insert(std::make_pair(
		client_handle,
		std::thread(
			[this, &client_socket] {
				std::cout << "Client communication thread started" << std::endl;
				StartClientCommunication(client_socket);
				std::cout << "Client communication thread ended" << std::endl;
			}
		)
	));
	std::cout << "Added client" << std::endl;
	return client_socket;
}

void Server::RemoveClient(Socket::Client& client) noexcept {
	std::cout << "Start remove client" << std::endl;
	// Set client status to disconnecting
	client.Status() = Connection::Status::Disconnecting;

	auto client_handle = *client.Handle();
	std::cout << "Start joining client message thread" << std::endl;
	// Join the client message thread
	if (m_clientMsgThreads.find(client_handle) != m_clientMsgThreads.end()) {
		if (m_clientMsgThreads[client_handle].joinable()) {
			m_clientMsgThreads[client_handle].join();
		}
		m_clientMsgThreads.erase(client_handle);
	}
	std::cout << "End joining client message thread" << std::endl;

	std::cout << "Start joining client thread" << std::endl;
	// Join the client thread
	if (m_clientThreads.find(client_handle) != m_clientThreads.end()) {
		if (m_clientThreads[client_handle].joinable()) {
			m_clientThreads[client_handle].join();
		}
		m_clientThreads.erase(client_handle);
	}
	std::cout << "End joining client thread" << std::endl;

	// Remove client from the vector
	m_clients.erase(std::remove_if(m_clients.begin(), m_clients.end(), [&client](const std::unique_ptr<Socket::Client>& c) {
		return c.get() == &client;
	}), m_clients.end());
	std::cout << "Client removed" << std::endl;
}

void Server::HandleClientMessages(Socket::Client& client) noexcept {
	fd_set readfds;
	FD_ZERO(&readfds);

	Connection::Handler::Type client_fd = *client.Handle();

	while (Connection::IsConnected(client.Status())) { // Keep processing as long as the client is connected
		FD_ZERO(&readfds);         // Reset fd_set for each iteration
		FD_SET(client_fd, &readfds);

		struct timeval timeout;
		timeout.tv_sec = 2;        // 5 seconds timeout
		timeout.tv_usec = 0;

		int activity = select(client_fd + 1, &readfds, nullptr, nullptr, &timeout);

		if (activity < 0) {
			// Handle select error (log or take action as needed)
			break;
		}
		else if (activity == 0) {
			// Timeout occurred, no activity on the socket
			continue; // Continue to the next iteration
		}
		else if (FD_ISSET(client_fd, &readfds)) {
			// Activity detected on the client's socket
			auto expected_message = HandleClientMessage(client);
			if (!expected_message) {
				client.Status() = Connection::Status::PeerClosed;
			}
			else {
				Util::Buffer message = std::move(expected_message.value());
				if (!this->PreProcessReceivedBuffer(client, message)) {
					client.Status() = Connection::Status::Error;
				}
				else {
					Util::Buffer response = this->ProcessMessage(client, message);
					// Send the response to the client
				}
			}
		}
	}
}

StormByte::Expected<StormByte::Util::Buffer, ConnectionClosed> Server::HandleClientMessage(Socket::Client& client) noexcept {
	// Read the message from the client
	auto expected_buffer = client.Receive();
	if (!expected_buffer)
		return StormByte::Unexpected(expected_buffer.error());

	return std::move(expected_buffer.value());
}

bool Server::NegotiateConnection(Socket::Client& client) noexcept {
	client.Status() = Connection::Status::Connected;
	return true;
}

bool Server::PreProcessReceivedBuffer(Socket::Client&, Util::Buffer&) noexcept {
	return true;
}

bool Server::PreProcessSendBuffer(Socket::Client&, Util::Buffer&) noexcept {
	return true;
}

StormByte::Util::Buffer Server::ProcessMessage(Socket::Client&, const Util::Buffer&) noexcept {
	return {};
}

void Server::StartClientCommunication(Socket::Client& client) noexcept {
	if (!this->NegotiateConnection(client)) {
		client.Status() = Connection::Status::Rejected;
		return;
	}
}

void Server::CheckClients() noexcept {
	std::cout << "Check clients started" << std::endl;
	while (Connection::IsConnected(m_status.load())) {
		// Lock vector access
		std::lock_guard<std::mutex> lock(m_clientsMutex);

		// Check if any clients have disconnected
		for (std::size_t i = m_clients.size(); i-- > 0; ) {
			if (!Connection::IsConnected(m_clients[i]->Status())) {
				RemoveClient(*m_clients[i]); // Safely process and remove the client
			}
		}
		Util::System::Sleep(1); // Sleep for 1 second
	}

	// If we reach here means server is disconnecting so we force close all clients
	// and stop accepting new clients
	if (m_acceptThread.joinable()) {
		m_acceptThread.join();
	}
	std::lock_guard<std::mutex> lock(m_clientsMutex);
	for (std::size_t i = m_clients.size(); i-- > 0; ) {
		RemoveClient(*m_clients[i]); // Safely process and remove the client
	}
	std::cout << "Check clients ended" << std::endl;
}